# 07: Middleware Overview

Middleware are functions or objects that process an incoming HTTP request, potentially modify it or the response, and then either pass control to the next middleware in the chain or finalize the request-response cycle.

In `qb::http`, middleware is a cornerstone for building extensible and maintainable web applications and APIs. It allows you to inject custom logic into the request processing pipeline in a modular and reusable way.

## The Role of Middleware

Middleware can perform a wide variety of tasks, such as:

-   **Logging**: Recording details about incoming requests and outgoing responses.
-   **Authentication/Authorization**: Verifying credentials and checking permissions (e.g., `AuthMiddleware`, `JwtMiddleware`).
-   **Data Parsing/Validation**: Parsing request bodies (e.g., JSON, form data) and validating them against schemas (e.g., `ValidationMiddleware`).
-   **Data Transformation**: Modifying request data before it reaches a handler, or transforming response data before it's sent to the client (e.g., `TransformMiddleware`, `CompressionMiddleware`).
-   **Header Manipulation**: Adding, removing, or modifying HTTP headers (e.g., `SecurityHeadersMiddleware`, `CorsMiddleware`).
-   **Rate Limiting**: Protecting services from abuse by limiting request frequency (e.g., `RateLimitMiddleware`).
-   **Caching Logic**: Implementing caching strategies.
-   **Error Handling**: Centralized processing of errors occurring during request handling (e.g., `ErrorHandlingMiddleware`).
-   **Serving Static Files**: Delivering static assets like HTML, CSS, and JavaScript files (e.g., `StaticFilesMiddleware`).

## The Middleware Interface: `IMiddleware`

All middleware components in `qb::http` typically implement the `qb::http::IMiddleware<SessionType>` interface (or are adapted to it, like functional middleware).

```cpp
// Defined in http/routing/middleware.h
template<typename SessionType>
class IMiddleware {
public:
    virtual ~IMiddleware() = default;

    // Core processing logic
    virtual void process(std::shared_ptr<Context<SessionType>> ctx) = 0;

    // Descriptive name for logging/debugging
    virtual std::string name() const = 0;

    // Called if the task chain processing is cancelled
    virtual void cancel() = 0;
};
```

-   `process(ctx)`: This is the main method where the middleware logic resides. It receives the request `Context`.
-   `name()`: Returns a descriptive name for the middleware, useful for logging and debugging.
-   `cancel()`: Called if the request processing is cancelled, allowing the middleware to clean up resources or abort ongoing asynchronous operations.

## Middleware Execution Flow and Control

Middleware components are organized into a chain. When a request matches a route, the router executes the compiled chain of tasks for that route. This chain includes all applicable middleware (global, group-specific, controller-specific) followed by the final route handler.

Each middleware's `process` method has control over the request lifecycle:

1.  **Perform Pre-processing**: Modify `ctx->request()` or `ctx->response()`, set custom data in `ctx->set(...)`.
2.  **Decision Point**:
    *   **Pass Control (`ctx->complete(AsyncTaskResult::CONTINUE)`)**: If the middleware has finished its processing and wants to pass control to the *next* middleware or handler in the chain, it calls `ctx->complete(AsyncTaskResult::CONTINUE)`.
    *   **Short-Circuit (`ctx->complete(AsyncTaskResult::COMPLETE)`)**: If the middleware can fully handle the request and generate a complete response (e.g., an authentication middleware denying access), it can populate `ctx->response()` and then call `ctx->complete(AsyncTaskResult::COMPLETE)`. This finalizes the request processing, and no further middleware or the main route handler in the current chain will be executed.
    *   **Signal Error (`ctx->complete(AsyncTaskResult::ERROR)`)**: If an unrecoverable error occurs within the middleware, it should call `ctx->complete(AsyncTaskResult::ERROR)`. This typically halts the current processing chain and diverts the request to the router's configured error handling chain (see [Error Handling Strategies](./13-error-handling.md)).
    *   **Signal Cancellation (`ctx->complete(AsyncTaskResult::CANCELLED)` or `ctx->cancel(reason)`)**: While middleware usually doesn't initiate cancellation itself, it might propagate a cancellation decision. `ctx->cancel()` is the more direct way to signal this.
3.  **Perform Post-processing (for some middleware types)**: Functional middleware (lambdas with a `next` callback) can perform actions *after* `next()` has returned, allowing them to modify the response generated by downstream middleware or the final handler.

### `AsyncTaskResult`

The `AsyncTaskResult` enum (defined in `http/routing/types.h`) is crucial for controlling the flow:

-   `CONTINUE`: Proceed to the next task in the current chain.
-   `COMPLETE`: This task has finalized the response. No further tasks in the current chain should run. Send the response.
-   `CANCELLED`: Processing was cancelled. Finalize and typically send an error response (e.g., 503 Service Unavailable).
-   `ERROR`: An error occurred. Invoke the router's error handling chain.
-   `FATAL_SPECIAL_HANDLER_ERROR`: A critical error within a special handler (404 or error chain itself). Respond with a generic 500.

## Synchronous vs. Asynchronous Middleware

Middleware can be synchronous or asynchronous:

-   **Synchronous Middleware**: Performs all its operations directly within the `process()` method and calls `ctx->complete(...)` before returning. Most common middleware types like header manipulation or simple checks are synchronous.

    ```cpp
    // Simplified Synchronous Middleware Example
    class MySyncMiddleware : public qb::http::IMiddleware<MySession> {
    public:
        std::string name() const override { return "MySyncMiddleware"; }
        void cancel() override {}
        void process(std::shared_ptr<qb::http::Context<MySession>> ctx) override {
            ctx->request().set_header("X-Sync-Processed", "true");
            // ... other synchronous logic ...
            ctx->complete(qb::http::AsyncTaskResult::CONTINUE); // Pass to next
        }
    };
    ```

-   **Asynchronous Middleware**: Initiates an operation that completes later (e.g., an external API call, a database query through `qb::io::async::callback`, or sending a message to another actor). The `process()` method typically starts the async operation and returns. The middleware is responsible for capturing the `ctx` (usually as a `std::shared_ptr`) and calling `ctx->complete(...)` in the callback or handler of the asynchronous operation.

    ```cpp
    // Simplified Asynchronous Middleware Example (Conceptual)
    class MyAsyncMiddleware : public qb::http::IMiddleware<MySession> {
    public:
        std::string name() const override { return "MyAsyncMiddleware"; }
        void cancel() override { /* logic to cancel pending async_op if possible */ }

        void process(std::shared_ptr<qb::http::Context<MySession>> ctx) override {
            auto shared_ctx = ctx; // Capture context for the lambda
            std::cout << "MyAsyncMiddleware: Starting async operation for " << shared_ctx->request().uri().path() << std::endl;

            // Simulate an async operation (e.g., using qb::io::async::callback)
            qb::io::async::callback([shared_ctx]() {
                std::cout << "MyAsyncMiddleware: Async operation completed for " << shared_ctx->request().uri().path() << std::endl;
                if (shared_ctx->is_cancelled()) {
                    // Context might have been cancelled while async op was pending
                    // The complete(CANCELLED) would have already been called by ctx->cancel().
                    // Or, if not, the middleware could decide to complete with CANCELLED here.
                    return; 
                }
                shared_ctx->response().set_header("X-Async-Op-Completed", "true");
                shared_ctx->complete(qb::http::AsyncTaskResult::CONTINUE);
            }, std::chrono::milliseconds(50)); // Simulate 50ms delay
        }
    };
    ```
    It's critical that asynchronous middleware correctly manages the `Context` lifecycle and ensures `complete()` is called exactly once.

## Middleware Chaining and Order

Middleware defined at different levels (router global, route group, controller) is compiled into a single, ordered chain for each specific route.
The execution order is generally:

1.  Router-level (global) middleware (in order of addition).
2.  Parent `RouteGroup` middleware (in order of addition).
3.  Child `RouteGroup` middleware (and so on for deeper nesting).
4.  `Controller`-specific middleware (in order of addition).
5.  The final route handler (`RouteHandlerFn` or `ICustomRoute::process`).

```
Request -> Router MW1 -> Router MW2 -> GroupA MW1 -> GroupB MW1 -> Controller MW1 -> Route Handler
```

If any middleware in this chain calls `ctx->complete(AsyncTaskResult::COMPLETE)` or `ctx->complete(AsyncTaskResult::ERROR)`, subsequent middleware and the route handler in *that specific chain* are typically skipped.

## Error Handling in Middleware

-   If a middleware encounters an error it cannot handle, it should call `ctx->complete(AsyncTaskResult::ERROR)`. This will usually trigger the router's configured error handling chain.
-   Middleware should be prepared for exceptions thrown by downstream tasks (if it uses `next()` like in functional middleware and performs post-processing) or by its own internal logic. The `MiddlewareTask` adapter typically catches exceptions from `IMiddleware::process` and signals an error to the context.

Middleware provides a clean and powerful way to add cross-cutting concerns and processing steps to your HTTP request handling logic.

Previous: [Controllers](./06-controllers.md)
Next: [Standard Middleware](./08-standard-middleware.md)

---
Return to [Index](./README.md) 